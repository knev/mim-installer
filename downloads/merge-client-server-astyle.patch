diff --git a/mcp940/src/minecraft/net/minecraft/inventory/ContainerEnchantment.java b/mcp940/src/minecraft/net/minecraft/inventory/ContainerEnchantment.java
index 322260f..3ac5551 100644
--- a/mcp940/src/minecraft/net/minecraft/inventory/ContainerEnchantment.java
+++ b/mcp940/src/minecraft/net/minecraft/inventory/ContainerEnchantment.java
@@ -23,18 +23,29 @@ import net.minecraft.world.World;
 public class ContainerEnchantment extends Container
 {
     /** SlotEnchantmentTable object with ItemStack to be enchanted */
-    public IInventory tableInventory;
+    public IInventory tableInventory = new InventoryBasic("Enchant", true, 2)
+    {
+        public int getInventoryStackLimit()
+        {
+            return 64;
+        }
+        public void markDirty()
+        {
+            super.markDirty();
+            ContainerEnchantment.this.onCraftMatrixChanged(this);
+        }
+    };
 
     /** current world (for bookshelf counting) */
     private final World worldPointer;
     private final BlockPos position;
-    private final Random rand;
+    private final Random rand = new Random();
     public int xpSeed;
 
     /** 3-member array storing the enchantment levels of each slot */
-    public int[] enchantLevels;
-    public int[] enchantClue;
-    public int[] worldClue;
+    public int[] enchantLevels = new int[3];
+    public int[] enchantClue = new int[] { -1, -1, -1};
+    public int[] worldClue = new int[] { -1, -1, -1};
 
     public ContainerEnchantment(InventoryPlayer playerInv, World worldIn)
     {
@@ -55,7 +66,7 @@ public class ContainerEnchantment extends Container
                 ContainerEnchantment.this.onCraftMatrixChanged(this);
             }
         };
-        this.rand = new Random();
+        //this.rand = new Random();
         this.enchantLevels = new int[3];
         this.enchantClue = new int[] { -1, -1, -1};
         this.worldClue = new int[] { -1, -1, -1};
diff --git a/mcp940/src/minecraft/net/minecraft/inventory/ContainerRepair.java b/mcp940/src/minecraft/net/minecraft/inventory/ContainerRepair.java
index 45c387b..5fd024e 100644
--- a/mcp940/src/minecraft/net/minecraft/inventory/ContainerRepair.java
+++ b/mcp940/src/minecraft/net/minecraft/inventory/ContainerRepair.java
@@ -22,12 +22,19 @@ public class ContainerRepair extends Container
     private static final Logger LOGGER = LogManager.getLogger();
 
     /** Here comes out item you merged and/or renamed. */
-    private final IInventory outputSlot;
+    private final IInventory outputSlot = new InventoryCraftResult();
 
     /**
      * The 2slots where you put your items in that you want to merge and/or rename.
      */
-    private final IInventory inputSlots;
+    private final IInventory inputSlots = new InventoryBasic("Repair", true, 2)
+    {
+        public void markDirty()
+        {
+            super.markDirty();
+            ContainerRepair.this.onCraftMatrixChanged(this);
+        }
+    };
     private final World theWorld;
     private final BlockPos selfPosition;
 
@@ -48,6 +55,7 @@ public class ContainerRepair extends Container
 
     public ContainerRepair(InventoryPlayer playerInventory, final World worldIn, final BlockPos blockPosIn, EntityPlayer player)
     {
+        /*
         this.outputSlot = new InventoryCraftResult();
         this.inputSlots = new InventoryBasic("Repair", true, 2)
         {
@@ -57,6 +65,7 @@ public class ContainerRepair extends Container
                 ContainerRepair.this.onCraftMatrixChanged(this);
             }
         };
+        */
         this.selfPosition = blockPosIn;
         this.theWorld = worldIn;
         this.thePlayer = player;
diff --git a/mcp940/src/minecraft/net/minecraft/network/rcon/RConConsoleSource.java b/mcp940/src/minecraft/net/minecraft/network/rcon/RConConsoleSource.java
index db761c6..ab9202d 100644
--- a/mcp940/src/minecraft/net/minecraft/network/rcon/RConConsoleSource.java
+++ b/mcp940/src/minecraft/net/minecraft/network/rcon/RConConsoleSource.java
@@ -16,6 +16,22 @@ public class RConConsoleSource implements ICommandSender
         this.server = serverIn;
     }
 
+    /**
+     * Clears the RCon log
+     */
+    public void resetLog()
+    {
+        this.buffer.setLength(0);
+    }
+
+    /**
+     * Gets the contents of the RCon log
+     */
+    public String getLogContents()
+    {
+        return this.buffer.toString();
+    }
+
     /**
      * Get the name of this object. For players this returns their username
      */
diff --git a/mcp940/src/minecraft/net/minecraft/server/MinecraftServer.java b/mcp940/src/minecraft/net/minecraft/server/MinecraftServer.java
index 9c8f224..2dc7671 100644
--- a/mcp940/src/minecraft/net/minecraft/server/MinecraftServer.java
+++ b/mcp940/src/minecraft/net/minecraft/server/MinecraftServer.java
@@ -46,12 +46,14 @@ import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.init.Bootstrap;
 import net.minecraft.network.NetworkSystem;
 import net.minecraft.network.ServerStatusResponse;
 import net.minecraft.network.play.server.SPacketTimeUpdate;
 import net.minecraft.profiler.ISnooperInfo;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.profiler.Snooper;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.management.PlayerList;
 import net.minecraft.server.management.PlayerProfileCache;
 import net.minecraft.util.IProgressUpdate;
@@ -60,6 +62,7 @@ import net.minecraft.util.ITickable;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.Util;
 import net.minecraft.util.datafix.DataFixer;
+import net.minecraft.util.datafix.DataFixesManager;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.text.ITextComponent;
@@ -99,6 +102,9 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
     private final Random random = new Random();
     private final DataFixer dataFixer;
 
+    /** The server's hostname. */
+    private String hostname;
+
     /** The server's port. */
     private int serverPort = -1;
 
@@ -506,6 +512,19 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         }
     }
 
+    /**
+     * "getHostname" is already taken, but both return the hostname.
+     */
+    public String getServerHostname()
+    {
+        return this.hostname;
+    }
+
+    public void setHostname(String host)
+    {
+        this.hostname = host;
+    }
+
     public boolean isServerRunning()
     {
         return this.serverRunning;
@@ -829,6 +848,132 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return true;
     }
 
+    public void registerTickable(ITickable tickable)
+    {
+        this.tickables.add(tickable);
+    }
+
+    public static void main(String[] p_main_0_)
+    {
+        Bootstrap.register();
+
+        try
+        {
+            boolean flag = true;
+            String s = null;
+            String s1 = ".";
+            String s2 = null;
+            boolean flag1 = false;
+            boolean flag2 = false;
+            int i = -1;
+
+            for (int j = 0; j < p_main_0_.length; ++j)
+            {
+                String s3 = p_main_0_[j];
+                String s4 = j == p_main_0_.length - 1 ? null : p_main_0_[j + 1];
+                boolean flag3 = false;
+
+                if (!"nogui".equals(s3) && !"--nogui".equals(s3))
+                {
+                    if ("--port".equals(s3) && s4 != null)
+                    {
+                        flag3 = true;
+
+                        try
+                        {
+                            i = Integer.parseInt(s4);
+                        }
+                        catch (NumberFormatException var13)
+                        {
+                            ;
+                        }
+                    }
+                    else if ("--singleplayer".equals(s3) && s4 != null)
+                    {
+                        flag3 = true;
+                        s = s4;
+                    }
+                    else if ("--universe".equals(s3) && s4 != null)
+                    {
+                        flag3 = true;
+                        s1 = s4;
+                    }
+                    else if ("--world".equals(s3) && s4 != null)
+                    {
+                        flag3 = true;
+                        s2 = s4;
+                    }
+                    else if ("--demo".equals(s3))
+                    {
+                        flag1 = true;
+                    }
+                    else if ("--bonusChest".equals(s3))
+                    {
+                        flag2 = true;
+                    }
+                }
+                else
+                {
+                    flag = false;
+                }
+
+                if (flag3)
+                {
+                    ++j;
+                }
+            }
+
+            YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(Proxy.NO_PROXY, UUID.randomUUID().toString());
+            MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
+            GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
+            PlayerProfileCache playerprofilecache = new PlayerProfileCache(gameprofilerepository, new File(s1, USER_CACHE_FILE.getName()));
+            final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1), DataFixesManager.createFixer(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, playerprofilecache);
+
+            if (s != null)
+            {
+                dedicatedserver.setServerOwner(s);
+            }
+
+            if (s2 != null)
+            {
+                dedicatedserver.setFolderName(s2);
+            }
+
+            if (i >= 0)
+            {
+                dedicatedserver.setServerPort(i);
+            }
+
+            if (flag1)
+            {
+                dedicatedserver.setDemo(true);
+            }
+
+            if (flag2)
+            {
+                dedicatedserver.canCreateBonusChest(true);
+            }
+
+            if (flag && !GraphicsEnvironment.isHeadless())
+            {
+                dedicatedserver.setGuiEnabled();
+            }
+
+            dedicatedserver.startServerThread();
+            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread")
+            {
+                public void run()
+                {
+                    dedicatedserver.stopServer();
+                }
+            });
+        }
+        catch (Exception exception)
+        {
+            LOG.fatal("Failed to start the minecraft server", (Throwable)exception);
+        }
+    }
+
     public void startServerThread()
     {
         this.serverThread = new Thread(this, "Server thread");
@@ -843,6 +988,14 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return new File(this.getDataDirectory(), fileName);
     }
 
+    /**
+     * Logs the message with a level of INFO.
+     */
+    public void logInfo(String msg)
+    {
+        LOG.info(msg);
+    }
+
     /**
      * Logs the message with a level of WARN.
      */
@@ -906,6 +1059,33 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return this.playerList.getAllProfiles();
     }
 
+    /**
+     * Returns true if debugging is enabled, false otherwise.
+     */
+    public boolean isDebuggingEnabled()
+    {
+        return false;
+    }
+
+    /**
+     * Logs the error message with a level of SEVERE.
+     */
+    public void logSevere(String msg)
+    {
+        LOG.error(msg);
+    }
+
+    /**
+     * If isDebuggingEnabled(), logs the message with a level of INFO.
+     */
+    public void logDebug(String msg)
+    {
+        if (this.isDebuggingEnabled())
+        {
+            LOG.info(msg);
+        }
+    }
+
     public String getServerModName()
     {
         return "vanilla";
@@ -1029,6 +1209,19 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return this.serverKeyPair;
     }
 
+    /**
+     * Gets serverPort.
+     */
+    public int getServerPort()
+    {
+        return this.serverPort;
+    }
+
+    public void setServerPort(int port)
+    {
+        this.serverPort = port;
+    }
+
     /**
      * Returns the username of the server owner (for integrated servers)
      */
@@ -1221,6 +1414,11 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return this.field_190519_A;
     }
 
+    public void func_190517_e(boolean p_190517_1_)
+    {
+        this.field_190519_A = p_190517_1_;
+    }
+
     public boolean getCanSpawnAnimals()
     {
         return this.canSpawnAnimals;
@@ -1362,11 +1560,27 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return this.worldServers[0];
     }
 
+    /**
+     * Return the spawn protection area's size.
+     */
+    public int getSpawnProtectionSize()
+    {
+        return 16;
+    }
+
     public boolean isBlockProtected(World worldIn, BlockPos pos, EntityPlayer playerIn)
     {
         return false;
     }
 
+    /**
+     * Set the forceGamemode field (whether joining players will be put in their old gamemode or the default one)
+     */
+    public void setForceGamemode(boolean force)
+    {
+        this.isGamemodeForced = force;
+    }
+
     /**
      * Get the forceGamemode field (whether joining players will be put in their old gamemode or the default one)
      */
@@ -1506,6 +1720,16 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return 256;
     }
 
+    public long getCurrentTime()
+    {
+        return this.currentTime;
+    }
+
+    public Thread getServerThread()
+    {
+        return this.serverThread;
+    }
+
     public int getSpawnRadius(@Nullable WorldServer worldIn)
     {
         return worldIn != null ? worldIn.getGameRules().getInt("spawnRadius") : 10;
diff --git a/mcp940/src/minecraft/net/minecraft/server/management/PlayerList.java b/mcp940/src/minecraft/net/minecraft/server/management/PlayerList.java
index 4524f85..71920d8 100644
--- a/mcp940/src/minecraft/net/minecraft/server/management/PlayerList.java
+++ b/mcp940/src/minecraft/net/minecraft/server/management/PlayerList.java
@@ -1021,6 +1021,11 @@ public abstract class PlayerList
         return this.mcServer.worldServers[0].getSaveHandler().getPlayerNBTManager().getAvailablePlayerDat();
     }
 
+    public boolean isWhiteListEnabled()
+    {
+        return this.whiteListEnforced;
+    }
+
     public void setWhiteListEnabled(boolean whitelistEnabled)
     {
         this.whiteListEnforced = whitelistEnabled;
diff --git a/mcp940/src/minecraft/net/minecraft/server/management/PreYggdrasilConverter.java b/mcp940/src/minecraft/net/minecraft/server/management/PreYggdrasilConverter.java
index 6ff47fb..c097857 100644
--- a/mcp940/src/minecraft/net/minecraft/server/management/PreYggdrasilConverter.java
+++ b/mcp940/src/minecraft/net/minecraft/server/management/PreYggdrasilConverter.java
@@ -3,16 +3,28 @@ package net.minecraft.server.management;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.io.Files;
 import com.mojang.authlib.Agent;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.ProfileLookupCallback;
+import com.mojang.authlib.yggdrasil.ProfileNotFoundException;
 import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.text.ParseException;
 import java.util.Collection;
+import java.util.Date;
 import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 import java.util.UUID;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.PropertyManager;
 import net.minecraft.util.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -25,6 +37,24 @@ public class PreYggdrasilConverter
     public static final File OLD_OPS_FILE = new File("ops.txt");
     public static final File OLD_WHITELIST_FILE = new File("white-list.txt");
 
+    static List<String> readFile(File inFile, Map<String, String[]> read) throws IOException
+    {
+        List<String> list = Files.readLines(inFile, StandardCharsets.UTF_8);
+
+        for (String s : list)
+        {
+            s = s.trim();
+
+            if (!s.startsWith("#") && s.length() >= 1)
+            {
+                String[] astring = s.split("\\|");
+                read.put(astring[0].toLowerCase(Locale.ROOT), astring);
+            }
+        }
+
+        return list;
+    }
+
     private static void lookupNames(MinecraftServer server, Collection<String> names, ProfileLookupCallback callback)
     {
         String[] astring = (String[])Iterators.toArray(Iterators.filter(names.iterator(), new Predicate<String>()
@@ -50,6 +80,250 @@ public class PreYggdrasilConverter
         }
     }
 
+    public static boolean convertUserBanlist(final MinecraftServer server) throws IOException
+    {
+        final UserListBans userlistbans = new UserListBans(PlayerList.FILE_PLAYERBANS);
+
+        if (OLD_PLAYERBAN_FILE.exists() && OLD_PLAYERBAN_FILE.isFile())
+        {
+            if (userlistbans.getSaveFile().exists())
+            {
+                try
+                {
+                    userlistbans.readSavedFile();
+                }
+                catch (FileNotFoundException filenotfoundexception)
+                {
+                    LOGGER.warn("Could not load existing file {}", userlistbans.getSaveFile().getName(), filenotfoundexception);
+                }
+            }
+
+            try
+            {
+                final Map<String, String[]> map = Maps.<String, String[]>newHashMap();
+                readFile(OLD_PLAYERBAN_FILE, map);
+                ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback()
+                {
+                    public void onProfileLookupSucceeded(GameProfile p_onProfileLookupSucceeded_1_)
+                    {
+                        server.getPlayerProfileCache().addEntry(p_onProfileLookupSucceeded_1_);
+                        String[] astring = map.get(p_onProfileLookupSucceeded_1_.getName().toLowerCase(Locale.ROOT));
+
+                        if (astring == null)
+                        {
+                            PreYggdrasilConverter.LOGGER.warn("Could not convert user banlist entry for {}", (Object)p_onProfileLookupSucceeded_1_.getName());
+                            throw new PreYggdrasilConverter.ConversionError("Profile not in the conversionlist");
+                        }
+                        else
+                        {
+                            Date date = astring.length > 1 ? PreYggdrasilConverter.parseDate(astring[1], (Date)null) : null;
+                            String s = astring.length > 2 ? astring[2] : null;
+                            Date date1 = astring.length > 3 ? PreYggdrasilConverter.parseDate(astring[3], (Date)null) : null;
+                            String s1 = astring.length > 4 ? astring[4] : null;
+                            userlistbans.addEntry(new UserListBansEntry(p_onProfileLookupSucceeded_1_, date, s, date1, s1));
+                        }
+                    }
+                    public void onProfileLookupFailed(GameProfile p_onProfileLookupFailed_1_, Exception p_onProfileLookupFailed_2_)
+                    {
+                        PreYggdrasilConverter.LOGGER.warn("Could not lookup user banlist entry for {}", p_onProfileLookupFailed_1_.getName(), p_onProfileLookupFailed_2_);
+
+                        if (!(p_onProfileLookupFailed_2_ instanceof ProfileNotFoundException))
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not request user " + p_onProfileLookupFailed_1_.getName() + " from backend systems", p_onProfileLookupFailed_2_);
+                        }
+                    }
+                };
+                lookupNames(server, map.keySet(), profilelookupcallback);
+                userlistbans.writeChanges();
+                backupConverted(OLD_PLAYERBAN_FILE);
+                return true;
+            }
+            catch (IOException ioexception)
+            {
+                LOGGER.warn("Could not read old user banlist to convert it!", (Throwable)ioexception);
+                return false;
+            }
+            catch (PreYggdrasilConverter.ConversionError preyggdrasilconverter$conversionerror)
+            {
+                LOGGER.error("Conversion failed, please try again later", (Throwable)preyggdrasilconverter$conversionerror);
+                return false;
+            }
+        }
+        else
+        {
+            return true;
+        }
+    }
+
+    public static boolean convertIpBanlist(MinecraftServer server) throws IOException
+    {
+        UserListIPBans userlistipbans = new UserListIPBans(PlayerList.FILE_IPBANS);
+
+        if (OLD_IPBAN_FILE.exists() && OLD_IPBAN_FILE.isFile())
+        {
+            if (userlistipbans.getSaveFile().exists())
+            {
+                try
+                {
+                    userlistipbans.readSavedFile();
+                }
+                catch (FileNotFoundException filenotfoundexception)
+                {
+                    LOGGER.warn("Could not load existing file {}", userlistipbans.getSaveFile().getName(), filenotfoundexception);
+                }
+            }
+
+            try
+            {
+                Map<String, String[]> map = Maps.<String, String[]>newHashMap();
+                readFile(OLD_IPBAN_FILE, map);
+
+                for (String s : map.keySet())
+                {
+                    String[] astring = map.get(s);
+                    Date date = astring.length > 1 ? parseDate(astring[1], (Date)null) : null;
+                    String s1 = astring.length > 2 ? astring[2] : null;
+                    Date date1 = astring.length > 3 ? parseDate(astring[3], (Date)null) : null;
+                    String s2 = astring.length > 4 ? astring[4] : null;
+                    userlistipbans.addEntry(new UserListIPBansEntry(s, date, s1, date1, s2));
+                }
+
+                userlistipbans.writeChanges();
+                backupConverted(OLD_IPBAN_FILE);
+                return true;
+            }
+            catch (IOException ioexception)
+            {
+                LOGGER.warn("Could not parse old ip banlist to convert it!", (Throwable)ioexception);
+                return false;
+            }
+        }
+        else
+        {
+            return true;
+        }
+    }
+
+    public static boolean convertOplist(final MinecraftServer server) throws IOException
+    {
+        final UserListOps userlistops = new UserListOps(PlayerList.FILE_OPS);
+
+        if (OLD_OPS_FILE.exists() && OLD_OPS_FILE.isFile())
+        {
+            if (userlistops.getSaveFile().exists())
+            {
+                try
+                {
+                    userlistops.readSavedFile();
+                }
+                catch (FileNotFoundException filenotfoundexception)
+                {
+                    LOGGER.warn("Could not load existing file {}", userlistops.getSaveFile().getName(), filenotfoundexception);
+                }
+            }
+
+            try
+            {
+                List<String> list = Files.readLines(OLD_OPS_FILE, StandardCharsets.UTF_8);
+                ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback()
+                {
+                    public void onProfileLookupSucceeded(GameProfile p_onProfileLookupSucceeded_1_)
+                    {
+                        server.getPlayerProfileCache().addEntry(p_onProfileLookupSucceeded_1_);
+                        userlistops.addEntry(new UserListOpsEntry(p_onProfileLookupSucceeded_1_, server.getOpPermissionLevel(), false));
+                    }
+                    public void onProfileLookupFailed(GameProfile p_onProfileLookupFailed_1_, Exception p_onProfileLookupFailed_2_)
+                    {
+                        PreYggdrasilConverter.LOGGER.warn("Could not lookup oplist entry for {}", p_onProfileLookupFailed_1_.getName(), p_onProfileLookupFailed_2_);
+
+                        if (!(p_onProfileLookupFailed_2_ instanceof ProfileNotFoundException))
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not request user " + p_onProfileLookupFailed_1_.getName() + " from backend systems", p_onProfileLookupFailed_2_);
+                        }
+                    }
+                };
+                lookupNames(server, list, profilelookupcallback);
+                userlistops.writeChanges();
+                backupConverted(OLD_OPS_FILE);
+                return true;
+            }
+            catch (IOException ioexception)
+            {
+                LOGGER.warn("Could not read old oplist to convert it!", (Throwable)ioexception);
+                return false;
+            }
+            catch (PreYggdrasilConverter.ConversionError preyggdrasilconverter$conversionerror)
+            {
+                LOGGER.error("Conversion failed, please try again later", (Throwable)preyggdrasilconverter$conversionerror);
+                return false;
+            }
+        }
+        else
+        {
+            return true;
+        }
+    }
+
+    public static boolean convertWhitelist(final MinecraftServer server) throws IOException
+    {
+        final UserListWhitelist userlistwhitelist = new UserListWhitelist(PlayerList.FILE_WHITELIST);
+
+        if (OLD_WHITELIST_FILE.exists() && OLD_WHITELIST_FILE.isFile())
+        {
+            if (userlistwhitelist.getSaveFile().exists())
+            {
+                try
+                {
+                    userlistwhitelist.readSavedFile();
+                }
+                catch (FileNotFoundException filenotfoundexception)
+                {
+                    LOGGER.warn("Could not load existing file {}", userlistwhitelist.getSaveFile().getName(), filenotfoundexception);
+                }
+            }
+
+            try
+            {
+                List<String> list = Files.readLines(OLD_WHITELIST_FILE, StandardCharsets.UTF_8);
+                ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback()
+                {
+                    public void onProfileLookupSucceeded(GameProfile p_onProfileLookupSucceeded_1_)
+                    {
+                        server.getPlayerProfileCache().addEntry(p_onProfileLookupSucceeded_1_);
+                        userlistwhitelist.addEntry(new UserListWhitelistEntry(p_onProfileLookupSucceeded_1_));
+                    }
+                    public void onProfileLookupFailed(GameProfile p_onProfileLookupFailed_1_, Exception p_onProfileLookupFailed_2_)
+                    {
+                        PreYggdrasilConverter.LOGGER.warn("Could not lookup user whitelist entry for {}", p_onProfileLookupFailed_1_.getName(), p_onProfileLookupFailed_2_);
+
+                        if (!(p_onProfileLookupFailed_2_ instanceof ProfileNotFoundException))
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not request user " + p_onProfileLookupFailed_1_.getName() + " from backend systems", p_onProfileLookupFailed_2_);
+                        }
+                    }
+                };
+                lookupNames(server, list, profilelookupcallback);
+                userlistwhitelist.writeChanges();
+                backupConverted(OLD_WHITELIST_FILE);
+                return true;
+            }
+            catch (IOException ioexception)
+            {
+                LOGGER.warn("Could not read old whitelist to convert it!", (Throwable)ioexception);
+                return false;
+            }
+            catch (PreYggdrasilConverter.ConversionError preyggdrasilconverter$conversionerror)
+            {
+                LOGGER.error("Conversion failed, please try again later", (Throwable)preyggdrasilconverter$conversionerror);
+                return false;
+            }
+        }
+        else
+        {
+            return true;
+        }
+    }
+
     public static String convertMobOwnerIfNeeded(final MinecraftServer server, String username)
     {
         if (!StringUtils.isNullOrEmpty(username) && username.length() <= 16)
@@ -88,4 +362,256 @@ public class PreYggdrasilConverter
             return username;
         }
     }
+
+    public static boolean convertSaveFiles(final DedicatedServer server, PropertyManager p_152723_1_)
+    {
+        final File file1 = getPlayersDirectory(p_152723_1_);
+        final File file2 = new File(file1.getParentFile(), "playerdata");
+        final File file3 = new File(file1.getParentFile(), "unknownplayers");
+
+        if (file1.exists() && file1.isDirectory())
+        {
+            File[] afile = file1.listFiles();
+            List<String> list = Lists.<String>newArrayList();
+
+            for (File file4 : afile)
+            {
+                String s = file4.getName();
+
+                if (s.toLowerCase(Locale.ROOT).endsWith(".dat"))
+                {
+                    String s1 = s.substring(0, s.length() - ".dat".length());
+
+                    if (!s1.isEmpty())
+                    {
+                        list.add(s1);
+                    }
+                }
+            }
+
+            try
+            {
+                final String[] astring = (String[])list.toArray(new String[list.size()]);
+                ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback()
+                {
+                    public void onProfileLookupSucceeded(GameProfile p_onProfileLookupSucceeded_1_)
+                    {
+                        server.getPlayerProfileCache().addEntry(p_onProfileLookupSucceeded_1_);
+                        UUID uuid = p_onProfileLookupSucceeded_1_.getId();
+
+                        if (uuid == null)
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Missing UUID for user profile " + p_onProfileLookupSucceeded_1_.getName());
+                        }
+                        else
+                        {
+                            this.renamePlayerFile(file2, this.getFileNameForProfile(p_onProfileLookupSucceeded_1_), uuid.toString());
+                        }
+                    }
+                    public void onProfileLookupFailed(GameProfile p_onProfileLookupFailed_1_, Exception p_onProfileLookupFailed_2_)
+                    {
+                        PreYggdrasilConverter.LOGGER.warn("Could not lookup user uuid for {}", p_onProfileLookupFailed_1_.getName(), p_onProfileLookupFailed_2_);
+
+                        if (p_onProfileLookupFailed_2_ instanceof ProfileNotFoundException)
+                        {
+                            String s2 = this.getFileNameForProfile(p_onProfileLookupFailed_1_);
+                            this.renamePlayerFile(file3, s2, s2);
+                        }
+                        else
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not request user " + p_onProfileLookupFailed_1_.getName() + " from backend systems", p_onProfileLookupFailed_2_);
+                        }
+                    }
+                    private void renamePlayerFile(File p_152743_1_, String p_152743_2_, String p_152743_3_)
+                    {
+                        File file5 = new File(file1, p_152743_2_ + ".dat");
+                        File file6 = new File(p_152743_1_, p_152743_3_ + ".dat");
+                        PreYggdrasilConverter.mkdir(p_152743_1_);
+
+                        if (!file5.renameTo(file6))
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not convert file for " + p_152743_2_);
+                        }
+                    }
+                    private String getFileNameForProfile(GameProfile p_152744_1_)
+                    {
+                        String s2 = null;
+
+                        for (String s3 : astring)
+                        {
+                            if (s3 != null && s3.equalsIgnoreCase(p_152744_1_.getName()))
+                            {
+                                s2 = s3;
+                                break;
+                            }
+                        }
+
+                        if (s2 == null)
+                        {
+                            throw new PreYggdrasilConverter.ConversionError("Could not find the filename for " + p_152744_1_.getName() + " anymore");
+                        }
+                        else
+                        {
+                            return s2;
+                        }
+                    }
+                };
+                lookupNames(server, Lists.newArrayList(astring), profilelookupcallback);
+                return true;
+            }
+            catch (PreYggdrasilConverter.ConversionError preyggdrasilconverter$conversionerror)
+            {
+                LOGGER.error("Conversion failed, please try again later", (Throwable)preyggdrasilconverter$conversionerror);
+                return false;
+            }
+        }
+        else
+        {
+            return true;
+        }
+    }
+
+    private static void mkdir(File dir)
+    {
+        if (dir.exists())
+        {
+            if (!dir.isDirectory())
+            {
+                throw new PreYggdrasilConverter.ConversionError("Can't create directory " + dir.getName() + " in world save directory.");
+            }
+        }
+        else if (!dir.mkdirs())
+        {
+            throw new PreYggdrasilConverter.ConversionError("Can't create directory " + dir.getName() + " in world save directory.");
+        }
+    }
+
+    public static boolean tryConvert(PropertyManager properties)
+    {
+        boolean flag = hasUnconvertableFiles(properties);
+        flag = flag && hasUnconvertablePlayerFiles(properties);
+        return flag;
+    }
+
+    private static boolean hasUnconvertableFiles(PropertyManager properties)
+    {
+        boolean flag = false;
+
+        if (OLD_PLAYERBAN_FILE.exists() && OLD_PLAYERBAN_FILE.isFile())
+        {
+            flag = true;
+        }
+
+        boolean flag1 = false;
+
+        if (OLD_IPBAN_FILE.exists() && OLD_IPBAN_FILE.isFile())
+        {
+            flag1 = true;
+        }
+
+        boolean flag2 = false;
+
+        if (OLD_OPS_FILE.exists() && OLD_OPS_FILE.isFile())
+        {
+            flag2 = true;
+        }
+
+        boolean flag3 = false;
+
+        if (OLD_WHITELIST_FILE.exists() && OLD_WHITELIST_FILE.isFile())
+        {
+            flag3 = true;
+        }
+
+        if (!flag && !flag1 && !flag2 && !flag3)
+        {
+            return true;
+        }
+        else
+        {
+            LOGGER.warn("**** FAILED TO START THE SERVER AFTER ACCOUNT CONVERSION!");
+            LOGGER.warn("** please remove the following files and restart the server:");
+
+            if (flag)
+            {
+                LOGGER.warn("* {}", (Object)OLD_PLAYERBAN_FILE.getName());
+            }
+
+            if (flag1)
+            {
+                LOGGER.warn("* {}", (Object)OLD_IPBAN_FILE.getName());
+            }
+
+            if (flag2)
+            {
+                LOGGER.warn("* {}", (Object)OLD_OPS_FILE.getName());
+            }
+
+            if (flag3)
+            {
+                LOGGER.warn("* {}", (Object)OLD_WHITELIST_FILE.getName());
+            }
+
+            return false;
+        }
+    }
+
+    private static boolean hasUnconvertablePlayerFiles(PropertyManager properties)
+    {
+        File file1 = getPlayersDirectory(properties);
+
+        if (!file1.exists() || !file1.isDirectory() || file1.list().length <= 0 && file1.delete())
+        {
+            return true;
+        }
+        else
+        {
+            LOGGER.warn("**** DETECTED OLD PLAYER DIRECTORY IN THE WORLD SAVE");
+            LOGGER.warn("**** THIS USUALLY HAPPENS WHEN THE AUTOMATIC CONVERSION FAILED IN SOME WAY");
+            LOGGER.warn("** please restart the server and if the problem persists, remove the directory '{}'", (Object)file1.getPath());
+            return false;
+        }
+    }
+
+    private static File getPlayersDirectory(PropertyManager properties)
+    {
+        String s = properties.getStringProperty("level-name", "world");
+        File file1 = new File(s);
+        return new File(file1, "players");
+    }
+
+    private static void backupConverted(File convertedFile)
+    {
+        File file1 = new File(convertedFile.getName() + ".converted");
+        convertedFile.renameTo(file1);
+    }
+
+    private static Date parseDate(String input, Date defaultValue)
+    {
+        Date date;
+
+        try
+        {
+            date = UserListEntryBan.DATE_FORMAT.parse(input);
+        }
+        catch (ParseException var4)
+        {
+            date = defaultValue;
+        }
+
+        return date;
+    }
+
+    static class ConversionError extends RuntimeException
+    {
+        private ConversionError(String message, Throwable cause)
+        {
+            super(message, cause);
+        }
+
+        private ConversionError(String message)
+        {
+            super(message);
+        }
+    }
 }
diff --git a/mcp940/src/minecraft/net/minecraft/server/management/UserList.java b/mcp940/src/minecraft/net/minecraft/server/management/UserList.java
index 31d5a77..bbc56c2 100644
--- a/mcp940/src/minecraft/net/minecraft/server/management/UserList.java
+++ b/mcp940/src/minecraft/net/minecraft/server/management/UserList.java
@@ -12,9 +12,12 @@ import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
+import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.Reader;
 import java.io.Writer;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -22,6 +25,7 @@ import java.nio.charset.StandardCharsets;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import net.minecraft.util.JsonUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -67,6 +71,11 @@ public class UserList<K, V extends UserListEntry<K>>
         this.lanServer = state;
     }
 
+    public File getSaveFile()
+    {
+        return this.saveFile;
+    }
+
     /**
      * Adds an entry to the list
      */
@@ -109,6 +118,11 @@ public class UserList<K, V extends UserListEntry<K>>
         return (String[])this.values.keySet().toArray(new String[this.values.size()]);
     }
 
+    public boolean isEmpty()
+    {
+        return this.values.size() < 1;
+    }
+
     /**
      * Gets the key value for the given object
      */
@@ -170,6 +184,38 @@ public class UserList<K, V extends UserListEntry<K>>
         }
     }
 
+    public void readSavedFile() throws IOException, FileNotFoundException
+    {
+        if (this.saveFile.exists())
+        {
+            Collection<UserListEntry<K>> collection = null;
+            BufferedReader bufferedreader = null;
+
+            try
+            {
+                bufferedreader = Files.newReader(this.saveFile, StandardCharsets.UTF_8);
+                collection = (Collection)JsonUtils.func_193841_a(this.gson, bufferedreader, USER_LIST_ENTRY_TYPE);
+            }
+            finally
+            {
+                IOUtils.closeQuietly((Reader)bufferedreader);
+            }
+
+            if (collection != null)
+            {
+                this.values.clear();
+
+                for (UserListEntry<K> userlistentry : collection)
+                {
+                    if (userlistentry.getValue() != null)
+                    {
+                        this.values.put(this.getObjectKey(userlistentry.getValue()), (V)userlistentry);
+                    }
+                }
+            }
+        }
+    }
+
     class Serializer implements JsonDeserializer<UserListEntry<K>>, JsonSerializer<UserListEntry<K>>
     {
         private Serializer()
diff --git a/mcp940/src/minecraft/net/minecraft/server/management/UserListWhitelist.java b/mcp940/src/minecraft/net/minecraft/server/management/UserListWhitelist.java
index 436f45e..148a3b9 100644
--- a/mcp940/src/minecraft/net/minecraft/server/management/UserListWhitelist.java
+++ b/mcp940/src/minecraft/net/minecraft/server/management/UserListWhitelist.java
@@ -16,6 +16,14 @@ public class UserListWhitelist extends UserList<GameProfile, UserListWhitelistEn
         return new UserListWhitelistEntry(entryData);
     }
 
+    /**
+     * Returns true if the profile is in the whitelist.
+     */
+    public boolean isWhitelisted(GameProfile profile)
+    {
+        return this.hasEntry(profile);
+    }
+
     public String[] getKeys()
     {
         String[] astring = new String[this.getValues().size()];
diff --git a/mcp940/src/minecraft/net/minecraft/world/Explosion.java b/mcp940/src/minecraft/net/minecraft/world/Explosion.java
index c633f30..05970ed 100644
--- a/mcp940/src/minecraft/net/minecraft/world/Explosion.java
+++ b/mcp940/src/minecraft/net/minecraft/world/Explosion.java
@@ -33,15 +33,15 @@ public class Explosion
 
     /** whether or not this explosion spawns smoke particles */
     private final boolean isSmoking;
-    private final Random explosionRNG;
+    private final Random explosionRNG = new Random();
     private final World worldObj;
     private final double explosionX;
     private final double explosionY;
     private final double explosionZ;
     private final Entity exploder;
     private final float explosionSize;
-    private final List<BlockPos> affectedBlockPositions;
-    private final Map<EntityPlayer, Vec3d> playerKnockbackMap;
+    private final List<BlockPos> affectedBlockPositions = Lists.<BlockPos>newArrayList();
+    private final Map<EntityPlayer, Vec3d> playerKnockbackMap = Maps.<EntityPlayer, Vec3d>newHashMap();
 
     public Explosion(World worldIn, Entity entityIn, double x, double y, double z, float size, List<BlockPos> affectedPositions)
     {
@@ -56,9 +56,11 @@ public class Explosion
 
     public Explosion(World worldIn, Entity entityIn, double x, double y, double z, float size, boolean flaming, boolean smoking)
     {
+        /*
         this.explosionRNG = new Random();
         this.affectedBlockPositions = Lists.<BlockPos>newArrayList();
         this.playerKnockbackMap = Maps.<EntityPlayer, Vec3d>newHashMap();
+        */
         this.worldObj = worldIn;
         this.exploder = entityIn;
         this.explosionSize = size;
